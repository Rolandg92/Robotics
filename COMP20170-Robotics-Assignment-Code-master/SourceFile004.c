#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro)
#pragma config(Motor,  motorB,          LMotor,        tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          RMotor,        tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float gn_dth_dt,gn_th,gn_y,gn_dy_dt,dt;

//Gain
const float PROPORTIONAL_GAIN = 0.0336;
const float INTEGRAL_GAIN = 0.2688;
const float DERIVATE_GAIN = 0.000504;

const float WHEEL_DIAMETER = 54;

//MATH CONSTANTS
const float RADIUS = WHEEL_DIAMETER/1000;
const int ACCELERATION = 50, SPEED = 25;

const int MOTOR_MAX = 20;// Number of previous measurements of motor speed

task main()
{
  dt = 0.010;

  // Customize PID constants. These variables are global, so you can optionally dynamically change them in your main task.
  gn_dth_dt = 0.23; // Angular velocity of robot (degree/sec)
  gn_th = 25.00; // Angle of robot
  gn_y = 272.8; // Measured Motor position (degrees)
  gn_dy_dt = 24.6; // Measured motor velocity (degrees/sec)



 	//SETUP VARIABLES FOR CALCULATIONS

  float robotAngle = 0,						// Theta
        robotAngularVelocity = 0;	// dTheta/dt

  float error = 0,            		// Sum of four states to be kept zero: robotAngle, robotAngularVelocity, motorPosition, motorVelocity.
        errorChange = 0,					// dError/dt
        integralError = 0,				// Accumulated error in time
        prevError = 0;						// Error found in previous cycle

  float pid = 0;                  // SUM OF PID CALCULATION

  float motorPosition = 0,	      // Measured Motor position (degrees)
        motorVelocity = 0,				//dMotor/dt  Measured motor velocity (degrees/sec)
	      velocity = 0,		          // Desired motor velocity (degrees/sec)
	      referencePos = 0;					// Desired motor position (degrees)

  int motorPower = 0,             // Power applied to motors
      powerChange = 0;            // Differents to change the motor power


  int encoder[MOTOR_MAX];                 // Array containing last MOTOR_MAX motor positions
  memset(&encoder[0],0,sizeof(encoder));
//  starting_balancing_task = false;// We're done configuring. Main task now resumes.


  clearTimer(T4);                 // This timer is used in the driver. Do not use it for other purposes!
	resetGyro(gyroSensor);
  while(true)
  {

    //READ GYRO SENSOR
		robotAngle=getGyroDegrees(gyroSensor);
		////////////
		//COMPUTE GYRO ANGULAR VELOCITY AND ESTIMATE ANGLE
  	//robotAngularVelocity = u/2 - mean_reading;
  	//mean_reading = mean_reading*0.999 + (0.001*(robotAngularVelocity + mean_reading));
  	//robotAngle = robotAngle + robotAngularVelocity * dt;

		//ADJUST REFERENCE POSITION ON SPEED AND ACCELERATION
    if(velocity < SPEED*10){
    velocity = velocity + ACCELERATION *10*dt;}
    else if(velocity > SPEED*10){
    velocity = velocity - ACCELERATION *10*dt;}
    referencePos = referencePos + velocity *dt;

  	//COMPUTE MOTOR ENCODER POSITION AND SPEED

  	//COMPUTE COMBINED ERROR AND PID VALUES
  	error = gn_th * robotAngle + gn_dth_dt * robotAngularVelocity + gn_y * motorPosition + gn_dy_dt * motorVelocity;
  	errorChange = (error - prevError)/dt;
  	integralError = integralError + error *dt;
  	prevError = error;
  	pid = (PROPORTIONAL_GAIN* error + INTEGRAL_GAIN * integralError + DERIVATE_GAIN * errorChange)/RADIUS;


  	//CONTROL MOTOR POWER AND STEERING
  	motorPower = pid;
    motor[RMotor] = 	motorPower + powerChange;
    motor[LMotor] = motorPower - powerChange;

    //ERROR CHECKING OR SHUTDOWN
    if(abs(robotAngle)>90 || abs(motorPower) > 2000){
      stopAllTasks();}

    //WAIT THEN REPEAT
  	while(time1[T4] < dt*1000){
  	  wait1Msec(1);}
  	clearTimer(T4);
  }
}

//https://github.com/richiprieto/GyroBoy-RobotC
