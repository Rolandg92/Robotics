#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro)
#pragma config(Motor,  motorB,          LMotor,        tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          RMotor,        tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard!!*//

//Ratio of gyro angle to angular velocity
const float ROBOT_ANGULAR_VELOCITY_RATIO = 0.25;
const float ROBOT_ANGLE_RATIO = 25;
const float ROBOT_MOTOR_RATIO = 0.33;

//Time Constant
const float dt = 0.01;

//Gain Constants
const float PROPORTIONAL_GAIN = 0.926;
const float INTEGRAL_GAIN = 2.5926;
const float DERIVATE_GAIN = 0.005556;


task main()
{

	eraseDisplay();
  displayCenteredTextLine(2,"Set Up");

  //VARIABLES
  long robotAngle = 0,						// Theta angle
       robotAngularVelocity = 0;	// dTheta/dt (degree/second)
  int  motorVelocity = 0;					//dMotor/dt  Measured motor velocity (degrees/sec)

  float error = 0,            		// Sum of four states to be kept zero: robotAngle, robotAngularVelocity, motorPosition, motorVelocity.
        errorChange = 0,					// dError/dt (error over time)
        integralError = 0,				// Accumulated error in time
        prevError = 0;						// Error found in previous cycle

  float pid = 0;                  // Sum of PID calculation


  // Timer is used to ensure a set time delay between cylces
  clearTimer(T1);

  //Reset the gyroSensor
	resetGyro(S2);

	sleep(2000);
	eraseDisplay();


	//While loop untill the robot falls over or the PID is to high
  while(abs(robotAngle)< 90 && abs(pid) < 2000)
  {


    //Read gyroSensor
		robotAngle = getGyroDegrees(gyroSensor);
		robotAngularVelocity = getGyroRate(gyroSensor);

		motorVelocity = (getMotorSpeed(RMotor) + getMotorSpeed(LMotor))/2;

	//Variables Display
  eraseDisplay();
  displayCenteredTextLine(2,"ERROR = %.2f, %.2f",error, PROPORTIONAL_GAIN* error);
  displayCenteredTextLine(3,"I_ERROR = %.2f, %.2f",integralError, INTEGRAL_GAIN * integralError);
  displayCenteredTextLine(4,"D_ERROR = %.2f, %.2f",errorChange, DERIVATE_GAIN * errorChange);
  displayCenteredTextLine(7,"PID = %.2f",pid);
  displayCenteredTextLine(9,"Angle = %.2f,", robotAngle);
  displayCenteredTextLine(10,"Angular = %ld", robotAngularVelocity);
  displayCenteredTextLine(11,"Motor = %ld", motorVelocity);



  	//Calculate the error
  	error = ROBOT_ANGLE_RATIO * robotAngle + ROBOT_ANGULAR_VELOCITY_RATIO * robotAngularVelocity + ROBOT_MOTOR_RATIO * motorVelocity;

  	//Calculate the error change over time
  	errorChange = (error - prevError)/dt;

  	//Calculate the error over time
  	integralError = integralError + error *dt;

  	prevError = error;

  	//Calculate the PID value
  	pid = PROPORTIONAL_GAIN * error + INTEGRAL_GAIN * integralError + DERIVATE_GAIN * errorChange;

		//Set the power of the motores
    motor[RMotor] = pid;
    motor[LMotor] = pid;


    //Wait till the minimium time of a cycle
  	while(time1[T1] < dt*1000){
  	  wait1Msec(1);
  	  }
  	clearTimer(T1);
  }
}
