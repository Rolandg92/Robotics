#pragma config(Sensor, S2,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S3,     lightSensor,    sensorEV3_Color, modeEV3Color_Color)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Constant Variables for the Robot
const int DEFAULT_SPEED = 30;
const int LINE_COLOUR = 5;
const int DEFAULT_TIME = 1000;
const int SHORT_DEFAULT_TIME = 100;


//Function to set the power of the robot motors to move in a straight line
void forward(int speed = DEFAULT_SPEED, int time = DEFAULT_TIME){
	//Set the power of the two motors
	motor[motorB] = speed;
	motor[motorC] = speed;

	//Wait time milliseconds
	wait1Msec(time);
}


//Function to move the robot forward in a straight line till the touch sensor
void forwardUnitilTouch(int speed){

	//Loop to keep the robot moving forward untill Touch sensor is pressed
	while (SensorValue(touchSensor) == 0){

		//Move the robot forward
		forward(speed, SHORT_DEFAULT_TIME);

	}
	//Stop the robots movement
	forward(0, DEFAULT_TIME);
}


//Function for turning L or R
void turning(char direction, int time){
	//Speed of the turn
	int speed = DEFAULT_SPEED;

	//if the direction is R/L? change the direction of the speed
	if(direction == 'L'){
		speed = speed * -1;
	}

	//Sets the motor speed for turning
	//Motors move in oppisite direction to make the robot turn
	motor[motorB] = speed;
	motor[motorC] = -speed;

	//Wait
	wait1Msec(time);

	//Stops the robot from turning
	forward(0, DEFAULT_TIME);
}


//Function to get the robot to follow a line
void followLine(bool wheelTurnModeOff, float numberOfWheelRotations){

	//Variables
	int turnspeed = DEFAULT_SPEED;
	//Sets the number of degrees at max each wheel can turn
	int degreesOfRotation = (int)(360 * numberOfWheelRotations);

	//Set the MotorEncoder to 0
	nMotorEncoder[motorC] = 0;
	nMotorEncoder[motorB] = 0;

	//While loop to loop until
	//1: The touch sensor is pressed or,
	//2: The wheelTurnMode is set to be on and one of the wheels execceds the Wheel Rotations
	while(SensorValue(touchSensor) == 0 && (wheelTurnModeOff || (nMotorEncoder[motorC] < degreesOfRotation && nMotorEncoder[motorB] < degreesOfRotation))){

		//Will track the left side of the line

		//If the colur detector see a light colour turn right onto the line
		if(SensorValue(lightSensor) != LINE_COLOUR){
			motor[motorC] = 0;
			motor[motorB] = turnspeed;
		}

		//Else on the line so turn left
		else{
			motor[motorC] = turnspeed;
			motor[motorB] = 0;
		}
	}

	//Stop the robot
	forward(0, DEFAULT_TIME);
}


//Function to have the robot search for a dark line in a zig zag method
void forwardTillLineZigZag(){

	//Variables for function
	int speed = DEFAULT_SPEED, time = SHORT_DEFAULT_TIME, maxTurns = 5;


	//When the robot finds the dark line
	while(SensorValue(lightSensor) != LINE_COLOUR){

		//For loop to turn right maxTurn time
		for(int i =0; i < maxTurns; i++){
			//Turn right
			motor[motorC] = 0;
			motor[motorB] = speed;
			wait1Msec(time);

			//If the robot is on the line return out of the function
			if(SensorValue(lightSensor) == LINE_COLOUR){
				//Stop the robot
				forward(0, DEFAULT_TIME);
				return;
			}
		}

		//For loop to turn left maxTurn time
		for(int i =0; i < maxTurns; i++){
			//Turn left
			motor[motorC] = speed;
			motor[motorB] = 0;
			wait1Msec(time);

			//If the robot is on the line return out of the function
			if(SensorValue(lightSensor) == LINE_COLOUR){
				//Stop the robot
				forward(0, DEFAULT_TIME);
				return;
			}
		}
	}

	//Stop the robot
	forward(0, DEFAULT_TIME);
}


//Function to have the robot search for a dark line in a straight line
void forwardTillLine(bool straightForward){

	//Variables for function
	int speed = DEFAULT_SPEED, time = SHORT_DEFAULT_TIME;

	//If straightForward = false then change the speed so the robot reverses
	if(!straightForward){
		speed = - speed;
	}

	//When the robot finds the dark line
	while(SensorValue(lightSensor) != LINE_COLOUR){
		forward(speed, time);
	}

	//Stop the robot
	forward(0, DEFAULT_TIME);
}


task main(){

	//From the start location move straight forward until the touch sensor touches the object
	forwardUnitilTouch(DEFAULT_SPEED);

	//Reverse the robot a small amount from the touched object
	forward(-DEFAULT_SPEED, 1500);

	//Turn the robot so is facing the correct direction to search for the line
	turning('L',800);

	//Use the forwardTillLineZigZag function to find the line by zig zaging across the table untill the line is found
	forwardTillLineZigZag();

	//followLine fuction in touch only mode to follow the line until the touch sesor hits the wall
	followLine(true, 0);

	//Reverse the robot a small amount from the wall to allow for turning
	forward(-DEFAULT_SPEED, 500);

	//Turn left so the robot can reverse backwards into the zone
	turning('L', 700);

	//Reverse a small amount so the robot pass over the line
	//(This is done so the forwardTillLine function does stop on the line the robot just followed instead will stop at zone line)
	forward(-DEFAULT_SPEED, 800);

	//Reverse the robot into the zone untill the front of the robot crosses the zone line
	forwardTillLine(false);

	//Forward a small amount so the robot pass over the zone line
	//(This is done so the forwardTillLine function does stop on the zone line)
	forward(DEFAULT_SPEED, 300);

	//Forward untill the robot reaches the line again
	forwardTillLine(true);

	//Turn the robot a small amount to line the robot up to follow the line
	turning('L', 300);

	//Follow the line but this time inable the robot to stop short of the end of the line
	//This is done by allowing no motor more than 6 rotations
	followLine(false, 6);

	//Turn the robot to face the wall
	turning('L', 600);

	//Move the robot forward untill the wal is touched
	forwardUnitilTouch(30);

	//Reverse from the wall to allow room to turn the robot
	forward(-DEFAULT_SPEED, 500);

	//Turn the robot to face the end zone
	turning('L', 800);

	//Move the robot forward untill it reaches the wall at the back of the end zone
	forwardUnitilTouch(30);

}
