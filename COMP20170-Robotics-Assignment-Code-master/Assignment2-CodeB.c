#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro)
#pragma config(Motor,  motorB,          LMotor,        tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          RMotor,        tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard!!*//

//Ratio of gyro angle to angular velocity
const float ROBOT_ANGULAR_VELOCITY_RATIO = 0.25;
const float ROBOT_ANGLE_RATIO = 25;

//Time Constant
const float dt = 0.01;

//Gain Constants
const float PROPORTIONAL_GAIN = 0.06;
const float INTEGRAL_GAIN = 0.11;//0.2;
const float DERIVATE_GAIN = 0.0006;//0.0003;

//Wheel Constants
const float WHEEL_DIAMETER = 54;
const float WHEEL_VALUE = WHEEL_DIAMETER/1000;


task main()
{
	eraseDisplay();
  displayCenteredTextLine(2,"Set Up");

  //VARIABLES
  long robotAngle = 0,						// Theta angle
        robotAngularVelocity = 0;	// dTheta/dt (degree/second)

  float error = 0,            		// Sum of four states to be kept zero: robotAngle, robotAngularVelocity, motorPosition, motorVelocity.
        errorChange = 0,					// dError/dt (error over time)
        integralError = 0,				// Accumulated error in time
        prevError = 0;						// Error found in previous cycle

  float pid = 0;                  // Sum of PID calculation


  // Timer is used to ensure a set time delay between cylces
  clearTimer(T1);

  //Reset the gyroSensor
	resetGyro(S2);

	sleep(2000);
	eraseDisplay();


	//While loop untill the robot falls over or the PID is to high
  while(abs(robotAngle)< 90 && abs(pid) < 2000)
  {


    //Read gyroSensor
		robotAngle = getGyroDegrees(gyroSensor);
		robotAngularVelocity = getGyroRate(gyroSensor);


  eraseDisplay();
  displayCenteredTextLine(2,"%ld, %ld", robotAngle, robotAngularVelocity);

  	//Calculate the error
  	error = ROBOT_ANGLE_RATIO * robotAngle + ROBOT_ANGULAR_VELOCITY_RATIO * robotAngularVelocity;

  	//Calculate the error change over time
  	errorChange = (error - prevError)/dt;

  	//Calculate the error over time
  	integralError = integralError + error *dt;

  	prevError = error;

  	//Calculate the PID value
  	pid = (PROPORTIONAL_GAIN* error + INTEGRAL_GAIN * integralError + DERIVATE_GAIN * errorChange)/WHEEL_VALUE;

		//Set the power of the motores
    motor[RMotor] = pid;
    motor[LMotor] = pid;


    //Wait till the minimium time of a cycle
  	while(time1[T1] < dt*1000){
  	  wait1Msec(1);
  	  }
  	clearTimer(T1);
  }
}
