#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro)
#pragma config(Motor,  motorB,          LMotor,        tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          RMotor,        tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float gn_dth_dt,gn_th,gn_y,gn_dy_dt,dt;

//Gain
const float PROPORTIONAL_GAIN = 0.06;
const float INTEGRAL_GAIN = 0.12;//0.2;
const float DERIVATE_GAIN = 0.0008;//0.0003;

const float WHEEL_DIAMETER = 54;

//MATH CONSTANTS
const float RADIUS = WHEEL_DIAMETER/1000;
const int ACCELERATION = 50, SPEED = 25;


task main()
{
  dt = 0.010;

  // Customize PID constants. These variables are global, so you can optionally dynamically change them in your main task.
  gn_dth_dt = 0.25; // Angular velocity of robot (degree/sec)
  gn_th = 25; // Angle of robot
  gn_y = 270; // Measured Motor position (degrees)
  gn_dy_dt = 24; // Measured motor velocity (degrees/sec)



 	//SETUP VARIABLES FOR CALCULATIONS

  float robotAngle = 0,						// Theta
        robotAngularVelocity = 0;	// dTheta/dt

  float error = 0,            		// Sum of four states to be kept zero: robotAngle, robotAngularVelocity, motorPosition, motorVelocity.
        errorChange = 0,					// dError/dt
        integralError = 0,				// Accumulated error in time
        prevError = 0;						// Error found in previous cycle

  float pid = 0;                  // SUM OF PID CALCULATION

  float motorPosition = 0,	      // Measured Motor position (degrees)
        motorVelocity = 0,				//dMotor/dt  Measured motor velocity (degrees/sec)
	      velocity = 0,		          // Desired motor velocity (degrees/sec)
	      referencePos = 0;					// Desired motor position (degrees)





  clearTimer(T1);                 // This timer is used in the driver. Do not use it for other purposes!
	resetGyro(gyroSensor);
  while(true)
  {

    //READ GYRO SENSOR
		robotAngle=getGyroDegrees(gyroSensor);


		//ADJUST REFERENCE POSITION ON SPEED AND ACCELERATION
    if(velocity < SPEED*10){
    	velocity = velocity + ACCELERATION *10*dt;
    }
    else if(velocity > SPEED*10){
    	velocity = velocity - ACCELERATION *10*dt;
    }

    referencePos = referencePos + velocity *dt;

  	//COMPUTE MOTOR ENCODER POSITION AND SPEED

  	//COMPUTE COMBINED ERROR AND PID VALUES
  	error = gn_th * robotAngle + gn_dth_dt * robotAngularVelocity + gn_y * motorPosition + gn_dy_dt * motorVelocity;

  	errorChange = (error - prevError)/dt;

  	integralError = integralError + error *dt;

  	prevError = error;

  	pid = (PROPORTIONAL_GAIN* error + INTEGRAL_GAIN * integralError + DERIVATE_GAIN * errorChange)/RADIUS;


  	//CONTROL MOTOR POWER AND STEERING

    motor[RMotor] = pid;
    motor[LMotor] = pid;

    //ERROR CHECKING OR SHUTDOWN
    if(abs(robotAngle)>90 || abs(pid) > 2000){
      stopAllTasks();
      }

    //WAIT THEN REPEAT
  	while(time1[T1] < dt*1000){
  	  wait1Msec(1);
  	  }
  	clearTimer(T1);
  }
}

//https://github.com/richiprieto/GyroBoy-RobotC
